export declare const sampleScala =
	'\npackage com.example.test\n\nimport scala.collection.mutable\nimport scala.concurrent.Future\n\n// Regular class with type parameters\nclass Container[A, B](val first: A, val second: B) {\n  def swap: Container[B, A] = new Container(second, first)\n}\n\n// Case class with type parameters\ncase class TestCaseClass[A, B](\n  field1: A,\n  field2: B,\n  field3: List[A]\n)(implicit ctx: Context)\n\n// Abstract class\nabstract class AbstractBase {\n  def abstractMethod: String\n  val abstractValue: Int\n}\n\n// Trait with abstract type member\ntrait TestTrait {\n  type T\n  def method[A](\n    param1: A,\n    param2: List[T]\n  ): Option[A]\n}\n\n// Object companion\nobject TestTrait {\n  def apply[T](value: T): TestTrait = ???\n}\n\n// Case object\ncase object SingletonValue extends AbstractBase {\n  def abstractMethod: String = "implemented"\n  val abstractValue: Int = 42\n}\n\n// Class with pattern matching\nclass PatternMatcher {\n  def testMatch(value: Any): Int = value match {\n    case s: String =>\n      s.length\n    case n: Int if n > 0 =>\n      n * 2\n    case _ =>\n      0\n  }\n}\n\n// Implicit class for extension methods\nimplicit class RichString(val str: String) {\n  def truncate(maxLength: Int): String =\n    if (str.length <= maxLength) str\n    else str.take(maxLength) + "..."\n}\n\n// Type alias and lazy val\nobject Types {\n  type StringMap[T] = Map[String, T]\n  \n  lazy val heavyComputation: Int = {\n    Thread.sleep(1000)\n    42\n  }\n}\n\n// For comprehension example\nclass ForComprehension {\n  def processItems(items: List[Int]): List[Int] = {\n    for {\n      item <- items\n      if item > 0\n      doubled = item * 2\n      if doubled < 100\n    } yield doubled\n  }\n}\n\n// Var and val definitions\nobject Variables {\n  val immutableValue: Int = 42\n  var mutableValue: String = "changeable"\n  \n  private lazy val lazyValue: Double = {\n    math.random()\n  }\n}'
//# sourceMappingURL=sample-scala.d.ts.map
